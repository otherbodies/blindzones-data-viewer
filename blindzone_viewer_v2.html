<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blind Zone Analysis - Vebj√∏rn's Geometric Method (Corrected)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e; 
            color: #eee;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; margin-bottom: 10px; color: #4fc3f7; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; font-size: 14px; }
        
        .upload-zone {
            border: 2px dashed #4fc3f7;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(79, 195, 247, 0.05);
        }
        .upload-zone:hover { background: rgba(79, 195, 247, 0.1); border-color: #81d4fa; }
        .upload-zone.dragover { background: rgba(79, 195, 247, 0.2); }
        .upload-icon { font-size: 48px; margin-bottom: 10px; }
        
        .main-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 1000px) { .main-layout { grid-template-columns: 1fr; } }
        
        .panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #0f3460;
        }
        .panel-title { 
            font-size: 14px; 
            text-transform: uppercase; 
            color: #4fc3f7; 
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        
        .controls { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .slider-container { flex: 1; min-width: 200px; }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
        }
        
        .play-btn {
            background: #4fc3f7;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        .play-btn:hover { background: #81d4fa; }
        
        .frame-info { 
            font-family: monospace; 
            color: #888; 
            min-width: 180px;
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap: 15px; 
        }
        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value { 
            font-size: 28px; 
            font-weight: bold; 
            font-family: monospace;
        }
        .stat-value.positive { color: #ff6b6b; }
        .stat-value.negative { color: #51cf66; }
        .stat-value.neutral { color: #ffd93d; }
        .stat-label { font-size: 11px; color: #888; margin-top: 5px; text-transform: uppercase; }
        
        canvas { 
            width: 100%; 
            height: auto;
            border-radius: 8px;
            background: #0a0a1a;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        
        .explanation {
            background: #0f3460;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            line-height: 1.6;
        }
        .explanation h4 { color: #4fc3f7; margin-bottom: 10px; }
        .explanation ul { margin-left: 20px; }
        
        .speed-control { display: flex; align-items: center; gap: 8px; }
        .speed-control select {
            background: #0f3460;
            color: #eee;
            border: 1px solid #4fc3f7;
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        const IPD = 0.0689;
        
        function quaternionToRightVector(qx, qy, qz, qw) {
            const rightX = 1 - 2 * (qy * qy + qz * qz);
            const rightY = 2 * (qx * qy + qw * qz);
            const rightZ = 2 * (qx * qz - qw * qy);
            const len = Math.sqrt(rightX * rightX + rightY * rightY + rightZ * rightZ);
            return [rightX / len, rightY / len, rightZ / len];
        }
        
        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
        }
        
        function horizontalAngle(ray) {
            return Math.atan2(ray[0], ray[2]);
        }
        
        function processData(rawData) {
            const n = rawData.length;
            
            const leftEdge = [
                parseFloat(rawData[0].LeftPillarEdgeCarLocalX),
                parseFloat(rawData[0].LeftPillarEdgeCarLocalY),
                parseFloat(rawData[0].LeftPillarEdgeCarLocalZ)
            ];
            const rightEdge = [
                parseFloat(rawData[0].RightPillarEdgeCarLocalX),
                parseFloat(rawData[0].RightPillarEdgeCarLocalY),
                parseFloat(rawData[0].RightPillarEdgeCarLocalZ)
            ];
            
            const frames = [];
            
            for (let i = 0; i < n; i++) {
                const row = rawData[i];
                const camPos = [
                    parseFloat(row.CarLocalPosX),
                    parseFloat(row.CarLocalPosY),
                    parseFloat(row.CarLocalPosZ)
                ];
                
                const qx = parseFloat(row.CarLocalRotQuatX);
                const qy = parseFloat(row.CarLocalRotQuatY);
                const qz = parseFloat(row.CarLocalRotQuatZ);
                const qw = parseFloat(row.CarLocalRotQuatW);
                
                const rightVec = quaternionToRightVector(qx, qy, qz, qw);
                
                const leftEye = [
                    camPos[0] - rightVec[0] * IPD / 2,
                    camPos[1] - rightVec[1] * IPD / 2,
                    camPos[2] - rightVec[2] * IPD / 2
                ];
                const rightEye = [
                    camPos[0] + rightVec[0] * IPD / 2,
                    camPos[1] + rightVec[1] * IPD / 2,
                    camPos[2] + rightVec[2] * IPD / 2
                ];
                
                const leftBoundary = normalize([
                    leftEdge[0] - leftEye[0],
                    leftEdge[1] - leftEye[1],
                    leftEdge[2] - leftEye[2]
                ]);
                const rightBoundary = normalize([
                    rightEdge[0] - rightEye[0],
                    rightEdge[1] - rightEye[1],
                    rightEdge[2] - rightEye[2]
                ]);
                
                const leftAngle = horizontalAngle(leftBoundary) * 180 / Math.PI;
                const rightAngle = horizontalAngle(rightBoundary) * 180 / Math.PI;
                
                frames.push({
                    index: i,
                    timestamp: parseFloat(row.Timestamp),
                    camPos,
                    leftEye,
                    rightEye,
                    leftAngle,
                    rightAngle,
                    instantDivergence: leftAngle - rightAngle
                });
            }
            
            // Compute cumulative divergence AND track which frames set the bounds
            let minLeft = frames[0].leftAngle;
            let maxRight = frames[0].rightAngle;
            let minLeftFrame = 0;
            let maxRightFrame = 0;
            
            for (let i = 0; i < frames.length; i++) {
                if (frames[i].leftAngle < minLeft) {
                    minLeft = frames[i].leftAngle;
                    minLeftFrame = i;
                }
                if (frames[i].rightAngle > maxRight) {
                    maxRight = frames[i].rightAngle;
                    maxRightFrame = i;
                }
                frames[i].cumulativeDivergence = minLeft - maxRight;
                frames[i].minLeftSoFar = minLeft;
                frames[i].maxRightSoFar = maxRight;
                frames[i].minLeftFrame = minLeftFrame;  // Track which frame set this bound
                frames[i].maxRightFrame = maxRightFrame;
            }
            
            return { frames, leftEdge, rightEdge };
        }
        
        function TopDownView({ data, currentFrame, width = 400, height = 400 }) {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!data || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, width, height);
                
                const frame = data.frames[currentFrame];
                const { leftEdge, rightEdge } = data;
                
                // Get the frames where cumulative bounds were set
                const leftBoundFrame = data.frames[frame.minLeftFrame];
                const rightBoundFrame = data.frames[frame.maxRightFrame];
                
                // Compute bounds for scaling
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                data.frames.forEach(f => {
                    minX = Math.min(minX, f.camPos[0]);
                    maxX = Math.max(maxX, f.camPos[0]);
                    minZ = Math.min(minZ, f.camPos[2]);
                    maxZ = Math.max(maxZ, f.camPos[2]);
                });
                minX = Math.min(minX, leftEdge[0], rightEdge[0]) - 0.1;
                maxX = Math.max(maxX, leftEdge[0], rightEdge[0]) + 0.1;
                minZ = Math.min(minZ, leftEdge[2], rightEdge[2]) - 0.1;
                maxZ = Math.max(maxZ, leftEdge[2], rightEdge[2]) + 0.1;
                
                const rangeX = maxX - minX;
                const rangeZ = maxZ - minZ;
                const scale = Math.min((width - 60) / rangeX, (height - 60) / rangeZ);
                
                const toScreen = (x, z) => [
                    30 + (x - minX) * scale,
                    height - 30 - (z - minZ) * scale
                ];
                
                // Draw trajectory (faded)
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                data.frames.forEach((f, i) => {
                    const [sx, sy] = toScreen(f.camPos[0], f.camPos[2]);
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                });
                ctx.stroke();
                
                // Draw pillar edges
                const [leX, leY] = toScreen(leftEdge[0], leftEdge[2]);
                const [reX, reY] = toScreen(rightEdge[0], rightEdge[2]);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(leX, leY, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(reX, reY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pillar bar
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(leX, leY);
                ctx.lineTo(reX, reY);
                ctx.stroke();
                
                // Current head position
                const [cx, cy] = toScreen(frame.camPos[0], frame.camPos[2]);
                
                // ===== INSTANT BLIND ZONE (from current position) =====
                // Draw rays from current position through pillar edges (this is the TRUE instant blind zone)
                const rayLength = 2.0; // in meters
                
                // Ray from current left eye through left edge
                const leftRayDir = normalize([
                    leftEdge[0] - frame.leftEye[0],
                    0,
                    leftEdge[2] - frame.leftEye[2]
                ]);
                const leftRayEnd = [
                    frame.leftEye[0] + leftRayDir[0] * rayLength,
                    frame.leftEye[2] + leftRayDir[2] * rayLength
                ];
                
                // Ray from current right eye through right edge
                const rightRayDir = normalize([
                    rightEdge[0] - frame.rightEye[0],
                    0,
                    rightEdge[2] - frame.rightEye[2]
                ]);
                const rightRayEnd = [
                    frame.rightEye[0] + rightRayDir[0] * rayLength,
                    frame.rightEye[2] + rightRayDir[2] * rayLength
                ];
                
                const [lrX, lrY] = toScreen(leftRayEnd[0], leftRayEnd[1]);
                const [rrX, rrY] = toScreen(rightRayEnd[0], rightRayEnd[1]);
                
                // Draw instant blind zone wedge (orange)
                ctx.fillStyle = 'rgba(255, 200, 100, 0.2)';
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(lrX, lrY);
                ctx.lineTo(rrX, rrY);
                ctx.closePath();
                ctx.fill();
                
                // Draw instant boundary rays (solid, from current position)
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(lrX, lrY);
                ctx.stroke();
                
                ctx.strokeStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(rrX, rrY);
                ctx.stroke();
                
                // ===== CUMULATIVE BOUNDS (from historical positions) =====
                // These rays come from DIFFERENT positions - where the bounds were set
                
                // Left cumulative bound: ray from the position where minLeft was set
                const [lbX, lbY] = toScreen(leftBoundFrame.camPos[0], leftBoundFrame.camPos[2]);
                const leftBoundRayDir = normalize([
                    leftEdge[0] - leftBoundFrame.leftEye[0],
                    0,
                    leftEdge[2] - leftBoundFrame.leftEye[2]
                ]);
                const leftBoundRayEnd = [
                    leftBoundFrame.leftEye[0] + leftBoundRayDir[0] * rayLength,
                    leftBoundFrame.leftEye[2] + leftBoundRayDir[2] * rayLength
                ];
                const [lbrX, lbrY] = toScreen(leftBoundRayEnd[0], leftBoundRayEnd[1]);
                
                // Right cumulative bound: ray from the position where maxRight was set
                const [rbX, rbY] = toScreen(rightBoundFrame.camPos[0], rightBoundFrame.camPos[2]);
                const rightBoundRayDir = normalize([
                    rightEdge[0] - rightBoundFrame.rightEye[0],
                    0,
                    rightEdge[2] - rightBoundFrame.rightEye[2]
                ]);
                const rightBoundRayEnd = [
                    rightBoundFrame.rightEye[0] + rightBoundRayDir[0] * rayLength,
                    rightBoundFrame.rightEye[2] + rightBoundRayDir[2] * rayLength
                ];
                const [rbrX, rbrY] = toScreen(rightBoundRayEnd[0], rightBoundRayEnd[1]);
                
                // Draw cumulative bound rays (dashed, from historical positions)
                ctx.setLineDash([8, 4]);
                ctx.lineWidth = 3;
                
                // Left bound ray (from historical position)
                ctx.strokeStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.moveTo(lbX, lbY);
                ctx.lineTo(lbrX, lbrY);
                ctx.stroke();
                
                // Right bound ray (from historical position)  
                ctx.strokeStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(rbX, rbY);
                ctx.lineTo(rbrX, rbrY);
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Mark the historical positions where bounds were set
                if (frame.minLeftFrame !== currentFrame) {
                    ctx.strokeStyle = '#4fc3f7';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(lbX, lbY, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (frame.maxRightFrame !== currentFrame) {
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(rbX, rbY, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw current head position (on top)
                ctx.fillStyle = '#51cf66';
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#888';
                ctx.font = '11px sans-serif';
                ctx.fillText('L', leX - 15, leY + 4);
                ctx.fillText('R', reX + 8, reY + 4);
                
            }, [data, currentFrame, width, height]);
            
            return <canvas ref={canvasRef} style={{ width, height }} />;
        }
        
        function AnglePlot({ data, currentFrame, width = 400, height = 200 }) {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!data || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, width, height);
                
                const frames = data.frames;
                const n = frames.length;
                const padL = 50, padR = 20, padT = 20, padB = 30;
                const plotW = width - padL - padR;
                const plotH = height - padT - padB;
                
                let minAngle = Infinity, maxAngle = -Infinity;
                frames.forEach(f => {
                    minAngle = Math.min(minAngle, f.leftAngle, f.rightAngle);
                    maxAngle = Math.max(maxAngle, f.leftAngle, f.rightAngle);
                });
                const angleRange = maxAngle - minAngle;
                minAngle -= angleRange * 0.1;
                maxAngle += angleRange * 0.1;
                
                const maxTime = frames[n - 1].timestamp;
                
                const toX = t => padL + (t / maxTime) * plotW;
                const toY = a => padT + plotH - ((a - minAngle) / (maxAngle - minAngle)) * plotH;
                
                // Grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padT + (plotH / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padL, y);
                    ctx.lineTo(width - padR, y);
                    ctx.stroke();
                }
                
                // Draw left angles (all frames)
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                frames.forEach((f, i) => {
                    const x = toX(f.timestamp);
                    const y = toY(f.leftAngle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Draw right angles (all frames)
                ctx.strokeStyle = '#ff6b6b';
                ctx.beginPath();
                frames.forEach((f, i) => {
                    const x = toX(f.timestamp);
                    const y = toY(f.rightAngle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Draw cumulative bounds up to current frame
                const frame = frames[currentFrame];
                
                // Cumulative left bound (horizontal line at minLeftSoFar)
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(padL, toY(frame.minLeftSoFar));
                ctx.lineTo(toX(frame.timestamp), toY(frame.minLeftSoFar));
                ctx.stroke();
                
                // Cumulative right bound (horizontal line at maxRightSoFar)
                ctx.strokeStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(padL, toY(frame.maxRightSoFar));
                ctx.lineTo(toX(frame.timestamp), toY(frame.maxRightSoFar));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Shade the effective blind zone region
                ctx.fillStyle = 'rgba(255, 80, 80, 0.15)';
                ctx.fillRect(padL, toY(frame.minLeftSoFar), 
                             toX(frame.timestamp) - padL, 
                             toY(frame.maxRightSoFar) - toY(frame.minLeftSoFar));
                
                // Current time marker
                ctx.strokeStyle = '#51cf66';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(toX(frame.timestamp), padT);
                ctx.lineTo(toX(frame.timestamp), height - padB);
                ctx.stroke();
                
                // Mark current values
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(toX(frame.timestamp), toY(frame.leftAngle), 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(toX(frame.timestamp), toY(frame.rightAngle), 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Axis labels
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Time (s)', width / 2, height - 5);
                
                ctx.save();
                ctx.translate(12, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Angle (¬∞)', 0, 0);
                ctx.restore();
                
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const angle = minAngle + (maxAngle - minAngle) * (1 - i / 4);
                    ctx.fillText(angle.toFixed(0), padL - 5, padT + (plotH / 4) * i + 4);
                }
                
            }, [data, currentFrame, width, height]);
            
            return <canvas ref={canvasRef} style={{ width, height }} />;
        }
        
        function DivergencePlot({ data, currentFrame, width = 400, height = 200 }) {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!data || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, width, height);
                
                const frames = data.frames;
                const n = frames.length;
                const padL = 50, padR = 20, padT = 20, padB = 30;
                const plotW = width - padL - padR;
                const plotH = height - padT - padB;
                
                let minDiv = Infinity, maxDiv = -Infinity;
                frames.forEach(f => {
                    minDiv = Math.min(minDiv, f.cumulativeDivergence, f.instantDivergence);
                    maxDiv = Math.max(maxDiv, f.cumulativeDivergence, f.instantDivergence);
                });
                const range = maxDiv - minDiv;
                minDiv -= range * 0.1;
                maxDiv += range * 0.1;
                minDiv = Math.min(minDiv, -5);
                maxDiv = Math.max(maxDiv, 5);
                
                const maxTime = frames[n - 1].timestamp;
                
                const toX = t => padL + (t / maxTime) * plotW;
                const toY = d => padT + plotH - ((d - minDiv) / (maxDiv - minDiv)) * plotH;
                
                // Zero line
                ctx.strokeStyle = '#51cf66';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(padL, toY(0));
                ctx.lineTo(width - padR, toY(0));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Initial divergence line
                const initialDiv = frames[0].instantDivergence;
                ctx.strokeStyle = '#ff6b6b';
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(padL, toY(initialDiv));
                ctx.lineTo(width - padR, toY(initialDiv));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw instant divergence (thin gray line)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                frames.forEach((f, i) => {
                    const x = toX(f.timestamp);
                    const y = toY(f.instantDivergence);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Fill improvement area
                ctx.fillStyle = 'rgba(81, 207, 102, 0.2)';
                ctx.beginPath();
                ctx.moveTo(toX(frames[0].timestamp), toY(initialDiv));
                frames.forEach((f, i) => {
                    if (i <= currentFrame) {
                        ctx.lineTo(toX(f.timestamp), toY(Math.min(f.cumulativeDivergence, initialDiv)));
                    }
                });
                ctx.lineTo(toX(frames[currentFrame].timestamp), toY(initialDiv));
                ctx.closePath();
                ctx.fill();
                
                // Draw cumulative divergence (thick blue line)
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 2;
                ctx.beginPath();
                frames.forEach((f, i) => {
                    if (i <= currentFrame) {
                        const x = toX(f.timestamp);
                        const y = toY(f.cumulativeDivergence);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Current point
                const frame = frames[currentFrame];
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(toX(frame.timestamp), toY(frame.cumulativeDivergence), 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Labels
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Time (s)', width / 2, height - 5);
                
                ctx.save();
                ctx.translate(12, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Divergence (¬∞)', 0, 0);
                ctx.restore();
                
                ctx.textAlign = 'right';
                ctx.fillText(maxDiv.toFixed(0), padL - 5, padT + 4);
                ctx.fillText(minDiv.toFixed(0), padL - 5, height - padB);
                ctx.fillStyle = '#51cf66';
                ctx.fillText('0', padL - 5, toY(0) + 4);
                
            }, [data, currentFrame, width, height]);
            
            return <canvas ref={canvasRef} style={{ width, height }} />;
        }
        
        function App() {
            const [data, setData] = useState(null);
            const [currentFrame, setCurrentFrame] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [playSpeed, setPlaySpeed] = useState(1);
            const [dragOver, setDragOver] = useState(false);
            const fileInputRef = useRef(null);
            const playIntervalRef = useRef(null);
            
            const handleFile = useCallback((file) => {
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: false,
                    complete: (results) => {
                        try {
                            const processed = processData(results.data.filter(row => row.Timestamp));
                            setData(processed);
                            setCurrentFrame(0);
                        } catch (e) {
                            alert('Error processing file: ' + e.message);
                        }
                    }
                });
            }, []);
            
            const handleDrop = useCallback((e) => {
                e.preventDefault();
                setDragOver(false);
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file);
            }, [handleFile]);
            
            const handleFileInput = useCallback((e) => {
                const file = e.target.files[0];
                if (file) handleFile(file);
            }, [handleFile]);
            
            useEffect(() => {
                if (isPlaying && data) {
                    playIntervalRef.current = setInterval(() => {
                        setCurrentFrame(prev => {
                            if (prev >= data.frames.length - 1) {
                                setIsPlaying(false);
                                return prev;
                            }
                            return prev + 1;
                        });
                    }, 100 / playSpeed);
                } else {
                    clearInterval(playIntervalRef.current);
                }
                return () => clearInterval(playIntervalRef.current);
            }, [isPlaying, data, playSpeed]);
            
            if (!data) {
                return (
                    <div className="container">
                        <h1>üöó Blind Zone Analysis (v2)</h1>
                        <p className="subtitle">Vebj√∏rn's Geometric Method - Corrected Visualization</p>
                        
                        <div 
                            className={`upload-zone ${dragOver ? 'dragover' : ''}`}
                            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
                            onDragLeave={() => setDragOver(false)}
                            onDrop={handleDrop}
                            onClick={() => fileInputRef.current.click()}
                        >
                            <div className="upload-icon">üìÅ</div>
                            <p>Drop CSV file here or click to upload</p>
                            <p style={{ fontSize: '12px', color: '#888', marginTop: '10px' }}>
                                Requires: CarLocalPosX/Y/Z, CarLocalRotQuatX/Y/Z/W, LeftPillarEdgeCarLocalX/Y/Z, RightPillarEdgeCarLocalX/Y/Z
                            </p>
                            <input 
                                ref={fileInputRef}
                                type="file" 
                                accept=".csv" 
                                style={{ display: 'none' }}
                                onChange={handleFileInput}
                            />
                        </div>
                        
                        <div className="explanation">
                            <h4>What's New in v2?</h4>
                            <p>The cumulative bound rays (dashed) are now drawn from their <strong>original positions</strong> where they were set, not from the current position. This correctly shows how the effective blind zone is defined by rays from different historical positions.</p>
                        </div>
                    </div>
                );
            }
            
            const frame = data.frames[currentFrame];
            const initialDiv = data.frames[0].instantDivergence;
            const reduction = initialDiv - frame.cumulativeDivergence;
            
            return (
                <div className="container">
                    <h1>üöó Blind Zone Analysis (v2)</h1>
                    
                    <div className="panel" style={{ marginBottom: 20 }}>
                        <div className="controls">
                            <button className="play-btn" onClick={() => setIsPlaying(!isPlaying)}>
                                {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
                            </button>
                            <button className="play-btn" onClick={() => { setCurrentFrame(0); setIsPlaying(false); }}>
                                ‚èÆ Reset
                            </button>
                            <div className="speed-control">
                                <span>Speed:</span>
                                <select value={playSpeed} onChange={(e) => setPlaySpeed(Number(e.target.value))}>
                                    <option value={0.5}>0.5x</option>
                                    <option value={1}>1x</option>
                                    <option value={2}>2x</option>
                                    <option value={4}>4x</option>
                                </select>
                            </div>
                            <div className="slider-container">
                                <input 
                                    type="range" 
                                    className="slider"
                                    min={0} 
                                    max={data.frames.length - 1} 
                                    value={currentFrame}
                                    onChange={(e) => setCurrentFrame(Number(e.target.value))}
                                />
                            </div>
                            <div className="frame-info">
                                Frame {currentFrame + 1} / {data.frames.length} | t = {frame.timestamp.toFixed(2)}s
                            </div>
                        </div>
                    </div>
                    
                    <div className="stats-grid" style={{ marginBottom: 20 }}>
                        <div className="stat-box">
                            <div className="stat-value neutral">{frame.instantDivergence.toFixed(1)}¬∞</div>
                            <div className="stat-label">Instant Blind Zone</div>
                        </div>
                        <div className="stat-box">
                            <div className={`stat-value ${frame.cumulativeDivergence < 0 ? 'negative' : 'positive'}`}>
                                {frame.cumulativeDivergence.toFixed(1)}¬∞
                            </div>
                            <div className="stat-label">Effective Blind Zone</div>
                        </div>
                        <div className="stat-box">
                            <div className="stat-value" style={{ color: '#4fc3f7' }}>{initialDiv.toFixed(1)}¬∞</div>
                            <div className="stat-label">Initial (baseline)</div>
                        </div>
                        <div className="stat-box">
                            <div className={`stat-value ${reduction > 0 ? 'negative' : 'positive'}`}>
                                {reduction > 0 ? '+' : ''}{reduction.toFixed(1)}¬∞
                            </div>
                            <div className="stat-label">Reduction</div>
                        </div>
                    </div>
                    
                    <div className="main-layout">
                        <div className="panel">
                            <div className="panel-title">Top-Down View</div>
                            <TopDownView data={data} currentFrame={currentFrame} width={400} height={350} />
                            <div className="legend">
                                <div className="legend-item"><div className="legend-color" style={{background: '#51cf66'}}></div> Current head</div>
                                <div className="legend-item"><div className="legend-color" style={{background: '#ff6b6b'}}></div> Pillar</div>
                                <div className="legend-item"><div className="legend-color" style={{background: 'rgba(255,200,100,0.5)'}}></div> Instant blind (solid rays)</div>
                                <div className="legend-item"><div className="legend-color" style={{background: '#4fc3f7'}}></div> Cumulative bounds (dashed, from historical pos)</div>
                            </div>
                            <p style={{ fontSize: 11, color: '#666', marginTop: 10, textAlign: 'center' }}>
                                Circles mark positions where cumulative bounds were set
                            </p>
                        </div>
                        
                        <div className="panel">
                            <div className="panel-title">Boundary Angles Over Time</div>
                            <AnglePlot data={data} currentFrame={currentFrame} width={400} height={180} />
                            <div className="legend">
                                <div className="legend-item"><div className="legend-color" style={{background: '#4fc3f7'}}></div> Left boundary</div>
                                <div className="legend-item"><div className="legend-color" style={{background: '#ff6b6b'}}></div> Right boundary</div>
                                <div className="legend-item"><div className="legend-color" style={{background: 'rgba(255,80,80,0.3)'}}></div> Effective zone</div>
                            </div>
                            
                            <div className="panel-title" style={{ marginTop: 20 }}>Effective Blind Zone (Cumulative)</div>
                            <DivergencePlot data={data} currentFrame={currentFrame} width={400} height={180} />
                            <div className="legend">
                                <div className="legend-item"><div className="legend-color" style={{background: '#4fc3f7'}}></div> Cumulative</div>
                                <div className="legend-item"><div className="legend-color" style={{background: 'rgba(255,255,255,0.3)'}}></div> Instantaneous</div>
                                <div className="legend-item"><div className="legend-color" style={{background: '#ff6b6b'}}></div> Initial</div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="explanation">
                        <h4>How to Read the Top-Down View</h4>
                        <ul>
                            <li><strong>Solid rays (blue/red):</strong> Current instantaneous blind zone from current head position</li>
                            <li><strong>Dashed rays:</strong> Cumulative bounds drawn from the <em>historical positions</em> where those extreme angles occurred</li>
                            <li><strong>Circles:</strong> Mark where cumulative bound positions differ from current position</li>
                        </ul>
                        <p style={{marginTop: 10}}>The effective blind zone is bounded by rays from <em>different</em> positions. When dashed rays from different positions cross (rather than diverge), the effective blind zone closes ‚Äî shown as negative divergence.</p>
                    </div>
                    
                    <p style={{ textAlign: 'center', marginTop: 20, color: '#666', fontSize: 12 }}>
                        <button className="play-btn" style={{ background: '#666', marginRight: 10 }} 
                                onClick={() => { setData(null); setCurrentFrame(0); }}>
                            Load Different File
                        </button>
                        IPD = {IPD}m | Vebj√∏rn's Geometric Method v2
                    </p>
                </div>
            );
        }
        
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
